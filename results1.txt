token(COMMENT, // ----------------------------------------------------------------------------)
token(COMMENT, //)
token(COMMENT, // This is the Fall 2023 target code for Compilers I.)
token(COMMENT, //)
token(COMMENT, // Your compiler should be able to lex, parse, and generate code for the)
token(COMMENT, // entire file by the end of the course.)
token(COMMENT, //)
token(COMMENT, // Written by: Craig C. Douglas)
token(COMMENT, // Modification history:)
token(COMMENT, //      Fri Aug 18 08:12:42 MDT 2023)
token(COMMENT, //)
token(COMMENT, // ----------------------------------------------------------------------------)
token(K_PROGRAM, program)
token(IDENTIFIER, $two_grid_solver)
token(LCURLY, {)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Place a constant in every element of a vector.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_PROCEDURE, procedure)
token(IDENTIFIER, set_constant)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dval)
token(COMMA, ,)
token(COMMENT, // The constant value)
token(K_DOUBLE, double)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, s1)
token(COMMENT, // Approximate solution)
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(COMMENT, // Loop variable)
token(K_WHILE, while)
token(LPAREN, ()
token(IDENTIFIER, i)
token(GEQ, >=)
token(ICONSTANT, 0)
token(DAND, &&)
token(IDENTIFIER, i)
token(LEQ, <=)
token(IDENTIFIER, s1)
token(RPAREN, ))
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dval)
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of set_constant)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Print every element of a vector, one per line with the index.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_PROCEDURE, procedure)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(K_STRING, string)
token(IDENTIFIER, title)
token(COMMA, ,)
token(COMMENT, // Identification of vector)
token(K_DOUBLE, double)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, s1)
token(COMMENT, // Approximate solution)
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Vector: ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "title")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\ni  value\n")
token(RPAREN, ))
token(SEMI, ;)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LEQ, <=)
token(IDENTIFIER, s1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(LCURLY, {)
token(K_PRINT_INTEGER, print_integer)
token(LPAREN, ()
token(IDENTIFIER, i)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, " ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_DOUBLE, print_double)
token(LPAREN, ()
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "--- End of vector\n")
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of print_vector)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Calculate the little ell-infinity norm of the error in the solution.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_FUNCTION, function)
token(K_DOUBLE, double)
token(IDENTIFIER, error_norm)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, s1)
token(COMMENT, // Approximate solution)
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(COMMENT, // Loop variable)
token(K_DOUBLE, double)
token(IDENTIFIER, asoln)
token(SEMI, ;)
token(COMMENT, // abs(dsoln[i]))
token(K_DOUBLE, double)
token(IDENTIFIER, l0_norm)
token(ASSIGN, :=)
token(DCONSTANT, 0.0d0)
token(SEMI, ;)
token(COMMENT, // Little L1 norm)
token(COMMENT, // The real solution is uniformly 0, so the maximum error is the)
token(COMMENT, // absolute value of the approximate solution)
token(K_WHILE, while)
token(LPAREN, ()
token(IDENTIFIER, i)
token(LEQ, <=)
token(IDENTIFIER, s1)
token(RPAREN, ))
token(LCURLY, {)
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(LEQ, <=)
token(DCONSTANT, 0.)
token(RPAREN, ))
token(K_THEN, then)
token(IDENTIFIER, asoln)
token(ASSIGN, :=)
token(MINUS, -)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(SEMI, ;)
token(K_ELSE, else)
token(IDENTIFIER, asoln)
token(ASSIGN, :=)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(SEMI, ;)
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, asoln)
token(GT, >)
token(IDENTIFIER, l0_norm)
token(RPAREN, ))
token(K_THEN, then)
token(LCURLY, {)
token(IDENTIFIER, l0_norm)
token(ASSIGN, :=)
token(IDENTIFIER, asoln)
token(SEMI, ;)
token(RCURLY, })
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(SEMI, ;)
token(RCURLY, })
token(K_RETURN, return)
token(IDENTIFIER, l0_norm)
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of error_norm)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Compute the residual vector.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_PROCEDURE, procedure)
token(IDENTIFIER, residuals)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, s1)
token(COMMA, ,)
token(COMMENT, // Approximate solution)
token(K_DOUBLE, double)
token(IDENTIFIER, drhs)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, rhs1)
token(COMMA, ,)
token(COMMENT, // Right hand side)
token(K_DOUBLE, double)
token(IDENTIFIER, dres)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, res1)
token(COMMENT, // Residuals)
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(SEMI, ;)
token(COMMENT, // Loop variable)
token(COMMENT, // Compute the residuals)
token(IDENTIFIER, dres)
token(LBRACKET, [)
token(ICONSTANT, 0)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dres)
token(LBRACKET, [)
token(IDENTIFIER, res1)
token(RBRACKET, ])
token(ASSIGN, :=)
token(DCONSTANT, 0.0d0)
token(SEMI, ;)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LT, <)
token(IDENTIFIER, s1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(IDENTIFIER, dres)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, drhs)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(MINUS, -)
token(DCONSTANT, 2.0)
token(MULTIPLY, *)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(DCONSTANT, -1)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of residuals)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Do some Gauss-Seidel iterations to approximate the solution.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_FUNCTION, function)
token(K_DOUBLE, double)
token(IDENTIFIER, gauss_seidel)
token(LPAREN, ()
token(K_INTEGER, integer)
token(IDENTIFIER, iters)
token(COMMA, ,)
token(COMMENT, // Number of iterations)
token(K_DOUBLE, double)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, s1)
token(COMMA, ,)
token(COMMENT, // Approximate solution)
token(K_DOUBLE, double)
token(IDENTIFIER, drhs)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, rhs1)
token(COMMENT, // Right hand side)
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(COMMA, ,)
token(IDENTIFIER, n)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(COMMENT, // Loop variables)
token(COMMENT, // Do iters number of Gauss-Seidel iterations )
token(K_WHILE, while)
token(LPAREN, ()
token(IDENTIFIER, n)
token(LEQ, <=)
token(IDENTIFIER, iters)
token(RPAREN, ))
token(LCURLY, {)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LT, <)
token(IDENTIFIER, s1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(ASSIGN, :=)
token(LPAREN, ()
token(IDENTIFIER, drhs)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(DCONSTANT, -1)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dsoln)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(RPAREN, ))
token(DIVIDE, /)
token(DCONSTANT, 2.0d0)
token(SEMI, ;)
token(IDENTIFIER, n)
token(INCREMENT, ++)
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // Return the error norm)
token(K_RETURN, return)
token(IDENTIFIER, error_norm)
token(LPAREN, ()
token(IDENTIFIER, dsoln)
token(COMMA, ,)
token(IDENTIFIER, s1)
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of gauss_seidel)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // Interpolate between the two grids.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_FUNCTION, function)
token(K_INTEGER, integer)
token(IDENTIFIER, interpolate)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, f1)
token(COMMA, ,)
token(COMMENT, // Original data, sized (f1)  )
token(K_DOUBLE, double)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, t1)
token(COMMENT, // Target date, sized  (t1)   )
token(RPAREN, ))
token(LCURLY, {)
token(COMMENT, // Two procedures defined only inside of interpolate)
token(COMMENT, // --------------------------------------------------------------------)
token(COMMENT, // Interpolate from the finer mesh to the coarser mesh.)
token(COMMENT, // --------------------------------------------------------------------)
token(K_PROCEDURE, procedure)
token(IDENTIFIER, coarsen)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, f1)
token(COMMA, ,)
token(COMMENT, // Original data, sized (f1)  )
token(K_DOUBLE, double)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, t1)
token(COMMENT, // Target date, sized  (t1)   )
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(COMMA, ,)
token(IDENTIFIER, m)
token(SEMI, ;)
token(COMMENT, // Loop variables   )
token(COMMENT, // Aggregate the from data in a Galerkin style on the coarser mesh  )
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(ICONSTANT, 0)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, t1)
token(RBRACKET, ])
token(ASSIGN, :=)
token(DCONSTANT, 0.)
token(SEMI, ;)
token(IDENTIFIER, m)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LT, <)
token(IDENTIFIER, t1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(LCURLY, {)
token(IDENTIFIER, m)
token(ASSIGN_PLUS, +=)
token(ICONSTANT, 2)
token(SEMI, ;)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(RBRACKET, ])
token(PLUS, +)
token(DCONSTANT, 5.d-1)
token(MULTIPLY, *)
token(LPAREN, ()
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(DCONSTANT, -1)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(RCURLY, })
token(COMMENT, // of coarsen)
token(COMMENT, // --------------------------------------------------------------------)
token(COMMENT, // Interpolate from the coarser mesh to the finer mesh and add to an)
token(COMMENT, // already existing approximate solution.)
token(COMMENT, // --------------------------------------------------------------------)
token(K_PROCEDURE, procedure)
token(IDENTIFIER, refine_add)
token(LPAREN, ()
token(K_DOUBLE, double)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, f1)
token(COMMA, ,)
token(COMMENT, // Original data, sized (f1)  )
token(K_DOUBLE, double)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(RBRACKET, ])
token(COMMA, ,)
token(K_INTEGER, integer)
token(IDENTIFIER, t1)
token(COMMENT, // Target date, sized  (t1)   )
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, i)
token(COMMA, ,)
token(IDENTIFIER, m)
token(SEMI, ;)
token(COMMENT, // Loop variables   )
token(COMMENT, // Deal with mesh points coincident between the two meshes  )
token(IDENTIFIER, m)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LT, <)
token(IDENTIFIER, f1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(LCURLY, {)
token(IDENTIFIER, m)
token(ASSIGN, :=)
token(IDENTIFIER, m)
token(PLUS, +)
token(ICONSTANT, 2)
token(SEMI, ;)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // Deal with mesh points noncoincident between the two meshes  )
token(IDENTIFIER, m)
token(ASSIGN, :=)
token(DCONSTANT, -1)
token(SEMI, ;)
token(K_DO, do)
token(LPAREN, ()
token(IDENTIFIER, i)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(IDENTIFIER, i)
token(LT, <)
token(IDENTIFIER, f1)
token(SEMI, ;)
token(IDENTIFIER, i)
token(INCREMENT, ++)
token(RPAREN, ))
token(LCURLY, {)
token(IDENTIFIER, m)
token(ASSIGN, :=)
token(IDENTIFIER, m)
token(PLUS, +)
token(ICONSTANT, 2)
token(SEMI, ;)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(RBRACKET, ])
token(ASSIGN, :=)
token(IDENTIFIER, dto)
token(LBRACKET, [)
token(IDENTIFIER, m)
token(RBRACKET, ])
token(PLUS, +)
token(DCONSTANT, .5)
token(MULTIPLY, *)
token(LPAREN, ()
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(RBRACKET, ])
token(PLUS, +)
token(IDENTIFIER, dfrom)
token(LBRACKET, [)
token(IDENTIFIER, i)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(RCURLY, })
token(COMMENT, // of refine_add)
token(COMMENT, // interpolate's code really starts here)
token(COMMENT, // Interpolate to a coarser mesh    )
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, t1)
token(DEQ, ==)
token(IDENTIFIER, f1)
token(DIVIDE, /)
token(ICONSTANT, 2)
token(RPAREN, ))
token(K_THEN, then)
token(IDENTIFIER, coarsen)
token(LPAREN, ()
token(IDENTIFIER, dfrom)
token(COMMA, ,)
token(IDENTIFIER, f1)
token(COMMA, ,)
token(IDENTIFIER, dto)
token(COMMA, ,)
token(IDENTIFIER, t1)
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Interpolate and add to what is on a finer mesh   )
token(K_ELSE, else)
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, t1)
token(DEQ, ==)
token(IDENTIFIER, f1)
token(MULTIPLY, *)
token(ICONSTANT, 2)
token(RPAREN, ))
token(K_THEN, then)
token(LCURLY, {)
token(IDENTIFIER, refine_add)
token(LPAREN, ()
token(IDENTIFIER, dfrom)
token(COMMA, ,)
token(IDENTIFIER, f1)
token(COMMA, ,)
token(IDENTIFIER, dto)
token(COMMA, ,)
token(IDENTIFIER, t1)
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // Uh, oh... this is incompatible   )
token(K_ELSE, else)
token(LCURLY, {)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Error in routine interp: data size mismatch.\n")
token(RPAREN, ))
token(SEMI, ;)
token(K_RETURN, return)
token(ICONSTANT, 0)
token(SEMI, ;)
token(RCURLY, })
token(K_RETURN, return)
token(ICONSTANT, 1)
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of interpolate)
token(COMMENT, // ------------------------------------------------------------------------)
token(COMMENT, // The actual two grid multilevel algorithm.)
token(COMMENT, // ------------------------------------------------------------------------)
token(K_FUNCTION, function)
token(K_INTEGER, integer)
token(IDENTIFIER, main)
token(LPAREN, ()
token(RPAREN, ))
token(LCURLY, {)
token(K_INTEGER, integer)
token(IDENTIFIER, rval)
token(ASSIGN, :=)
token(ICONSTANT, 0)
token(SEMI, ;)
token(COMMENT, // Return value)
token(K_INTEGER, integer)
token(IDENTIFIER, fm1)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(SEMI, ;)
token(COMMENT, // Fine and coarse mesh upper limits)
token(K_DOUBLE, double)
token(IDENTIFIER, enorm)
token(SEMI, ;)
token(COMMENT, // Error norm)
token(COMMENT, // Determine fine mesh size.  Coarse mesh is roughly half the size.)
token(K_WHILE, while)
token(LPAREN, ()
token(IDENTIFIER, fm1)
token(LEQ, <=)
token(ICONSTANT, 4)
token(IDENTIFIER, fm1)
token(MOD, %)
token(ICONSTANT, 2)
token(NE, !=)
token(ICONSTANT, 0)
token(RPAREN, ))
token(LCURLY, {)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Number of points in the fine mesh (must be even and atleast 6) ")
token(RPAREN, ))
token(SEMI, ;)
token(K_READ_INTEGER, read_integer)
token(LPAREN, ()
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(RCURLY, })
token(IDENTIFIER, cm1)
token(ASSIGN, :=)
token(IDENTIFIER, fm1)
token(DIVIDE, /)
token(ICONSTANT, 2)
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Fine   mesh points 0:")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_INTEGER, print_integer)
token(LPAREN, ()
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\nCoarse mesh points 0:")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_INTEGER, print_integer)
token(LPAREN, ()
token(IDENTIFIER, cm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\n")
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Allocate space dynamically)
token(K_DOUBLE, double)
token(IDENTIFIER, fm)
token(LBRACKET, [)
token(IDENTIFIER, fm1)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(COMMA, ,)
token(COMMENT, // Fine grid approximate solution)
token(IDENTIFIER, frhs)
token(LBRACKET, [)
token(IDENTIFIER, fm1)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(COMMA, ,)
token(COMMENT, // Fine grid right hand side)
token(IDENTIFIER, fres)
token(LBRACKET, [)
token(IDENTIFIER, fm1)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(SEMI, ;)
token(COMMENT, // Fine grid residuals)
token(K_DOUBLE, double)
token(IDENTIFIER, cm)
token(LBRACKET, [)
token(IDENTIFIER, cm1)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(COMMA, ,)
token(IDENTIFIER, crhs)
token(LBRACKET, [)
token(IDENTIFIER, cm1)
token(PLUS, +)
token(ICONSTANT, 1)
token(RBRACKET, ])
token(SEMI, ;)
token(COMMENT, // Coarse grid solution and right)
token(COMMENT, // hand side)
token(COMMENT, // Set the initial guess to the solution)
token(IDENTIFIER, set_constant)
token(LPAREN, ()
token(DCONSTANT, 1.0d0)
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, fm)
token(LBRACKET, [)
token(ICONSTANT, 0)
token(RBRACKET, ])
token(ASSIGN, :=)
token(DCONSTANT, 0.0d0)
token(SEMI, ;)
token(IDENTIFIER, fm)
token(LBRACKET, [)
token(IDENTIFIER, fm1)
token(RBRACKET, ])
token(ASSIGN, :=)
token(DCONSTANT, 0.)
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "Initial guess")
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Get the initial error norm)
token(IDENTIFIER, enorm)
token(ASSIGN, :=)
token(IDENTIFIER, error_norm)
token(LPAREN, ()
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "initial error norm := ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_DOUBLE, print_double)
token(LPAREN, ()
token(IDENTIFIER, enorm)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\n")
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Do some Gauss-Seidel iterations on the fine mesh)
token(IDENTIFIER, enorm)
token(ASSIGN, :=)
token(IDENTIFIER, gauss_seidel)
token(LPAREN, ()
token(ICONSTANT, 4)
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(COMMA, ,)
token(IDENTIFIER, frhs)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "after first fine mesh smoothing")
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Fine mesh error norm := ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_DOUBLE, print_double)
token(LPAREN, ()
token(IDENTIFIER, enorm)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\n")
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Compute the residuals on the fine mesh and project them onto the)
token(COMMENT, // coarse mesh right hand side.)
token(IDENTIFIER, residuals)
token(LPAREN, ()
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(COMMA, ,)
token(IDENTIFIER, frhs)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(COMMA, ,)
token(IDENTIFIER, fres)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "Residuals on fine mesh")
token(COMMA, ,)
token(IDENTIFIER, fres)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, interpolate)
token(LPAREN, ()
token(IDENTIFIER, fres)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(COMMA, ,)
token(IDENTIFIER, crhs)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(RPAREN, ))
token(NE, !=)
token(ICONSTANT, 0)
token(RPAREN, ))
token(K_THEN, then)
token(K_RETURN, return)
token(IDENTIFIER, rval)
token(ASSIGN, :=)
token(ICONSTANT, 1)
token(SEMI, ;)
token(COMMENT, // Do some Gauss-Seidel iterations on the coarse mesh)
token(IDENTIFIER, enorm)
token(ASSIGN, :=)
token(IDENTIFIER, gauss_seidel)
token(LPAREN, ()
token(ICONSTANT, 500)
token(COMMA, ,)
token(IDENTIFIER, cm)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(COMMA, ,)
token(IDENTIFIER, crhs)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "coarse mesh correction")
token(COMMA, ,)
token(IDENTIFIER, cm)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Interpolate the correction to the fine grid)
token(K_IF, if)
token(LPAREN, ()
token(IDENTIFIER, interpolate)
token(LPAREN, ()
token(IDENTIFIER, cm)
token(COMMA, ,)
token(IDENTIFIER, cm1)
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(GT, >)
token(ICONSTANT, 0)
token(RPAREN, ))
token(K_THEN, then)
token(K_RETURN, return)
token(ICONSTANT, 2)
token(SEMI, ;)
token(IDENTIFIER, enorm)
token(ASSIGN, :=)
token(IDENTIFIER, error_norm)
token(LPAREN, ()
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Fine mesh error norm := ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_DOUBLE, print_double)
token(LPAREN, ()
token(IDENTIFIER, enorm)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\n")
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "after interpolation to fine mesh")
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // Do some Gauss-Seidel iterations on the fine mesh)
token(IDENTIFIER, enorm)
token(ASSIGN, :=)
token(IDENTIFIER, gauss_seidel)
token(LPAREN, ()
token(ICONSTANT, 4)
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(COMMA, ,)
token(IDENTIFIER, frhs)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(IDENTIFIER, print_vector)
token(LPAREN, ()
token(SCONSTANT, "after second fine mesh smoothing")
token(COMMA, ,)
token(IDENTIFIER, fm)
token(COMMA, ,)
token(IDENTIFIER, fm1)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "Fine mesh error norm := ")
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_DOUBLE, print_double)
token(LPAREN, ()
token(IDENTIFIER, enorm)
token(RPAREN, ))
token(SEMI, ;)
token(K_PRINT_STRING, print_string)
token(LPAREN, ()
token(SCONSTANT, "\n")
token(RPAREN, ))
token(SEMI, ;)
token(COMMENT, // All done.  Return 0 if everything worked out or something else if)
token(COMMENT, // something went wrong.)
token(K_RETURN, return)
token(IDENTIFIER, rval)
token(SEMI, ;)
token(RCURLY, })
token(COMMENT, // of main)
token(RCURLY, })
token(COMMENT, // of program $two_grid_solver)
